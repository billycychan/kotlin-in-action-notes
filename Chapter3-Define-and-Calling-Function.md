# 3.  Defining and calling functions

## 3.1 Creating collections in Kotlin

```kotlin
// Kotlin uses the standard Java collection classes.
val set = setOf(1, 7, 53)
val list = listOf(1, 7, 53)
val map = mapOf(1 to "one", 7 to "seven". 53 to "fifty-three")

fun main() {
    println(set.javaClass)
    println(list.javaClass)
    println(map.javaClass)
}

/**
class java.util.LinkedHashSet
class java.util.Arrays$ArrayList
class java.util.LinkedHashMap
**/
```





```kotlin
// We can do much more with Kotlin's collection
fun main() {
    val strings = listOf("first", "second", "fourteenth")
    println(strings.last())
    val numbers = setOf(1, 14, 2)
    println(numbers.sum())
}
// [fourteenth, second, first]
// 17
```



## 3.2 Making functions easier to call

```kotlin
package ch03.JoinToString

fun <T> joinToString(
    collection: Collection<T>,
    separator: String,
    prefix: String,
    postfix: String
): String {

    val result = StringBuilder(prefix)

    for ((index, element) in collection.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(element)
    }

    result.append(postfix)
    return result.toString()
}

fun main() {
    val list = listOf(1, 2, 3)
    println(joinToString(list, "; ", "(", ")"))
}
```

How can you change it to make calls of this function **less verbose**?

### 3.2.1 Named arguments

Problems:

```kotlin
joinToString(collection, " ", " ", ".")
```

We could not know what parameters all these `Strings` correspond to. It is not obvious from the calling code.

We could use it with named arguments

```kotlin
joinToString(collection, separator = " ", prefix = " ", postfix = ".")”
```

### 3.2.2 Default parameter values

In Kotlin, with default parameter values, it solves the overabundance of overloaded methods in some classes. e.g. Thread has eight constructors.

```kotlin
fun <T> Collection<T>.joinToString(
        separator: String = ", ",
        prefix: String = "",
        postfix: String = ""
): String

fun main() {
    joinToString(list, ", ", "", "")
    // 1, 2, 3
    joinToString(list)
    // 1, 2, 3
    joinToString(list, "; ")
    // 1; 2; 3
}
```

If you frequently need to call a function from Java and want to make it easier to use for Java callers, you can annotate it with `@JvmOverloads`.

This instructs the compiler to generate Java overloaded methods, omitting each of the parameters one by one, starting from the last one. 

### 3.2.3 Getting rid of static utility calsses: Top-level functions and properties

Java as OOP usually requires all code to be written as methods of classes. 

In Kotlin, you dont't need to create all those meaningless classes. Instead, you can place functions directly at the top level of a source file, outside of any class.

```kotlin
/* join.kt */
package strings
fun joinToString(/* ... */): String { /* ... */}
```

```java
/*
Java code that would compile the same class
*/ 
package strings;
 
public class JoinKt {    
    public static String joinToString(/* ... */) { /* ... */ }
}
```

the name of the class generated by the Kotlin compiler corresponds to the name of the file containing the function—capitalized to match Java’s naming scheme and suffixed with Kt. 

To change the file class name, we could use file-wide annotation `@file:JvmName("...")`  Place it at the beginning of the file, before the package name.



**Top-Level Properties**

```kotlin
var opCount = 0

fun performOperation() {
  opCount++
}

fun reportOperationCount() {
  println("Operation performed $opCount times")
}

const val UNIX_LINE_SEPARATOR = "\n"
“/* Java */
public static final String UNIX_LINE_SEPARATOR = "\n";”
```



`kotlin.math` contains the top-level functions and properties provides useful functions for typical mathematical and trigonometric operations. 

```kotlin
fun main() {
    println(max(PI, E))
    // 3.141592653589793
}
```



## 3.3 Adding methods to other people's classes: Extention functions and properties

An extension function is a function that can be called as a member of a class but is defined outside of it.

```kotlin
package strings

fun String.lastChar(): Char = this.get(this.length - 1)
fun String.lastChar(): Char = get(length - 1) 
```

“All you need to do is **put the name of the class or interface you’re extending** before **the name of the function you’re adding**. 

This class name is called **the receiver type**; the value on which you’re calling the extension function is called **the receiver object**.

`String` is the receiver type and `"Kotlin"` is the receiver object



```kotlin
fun main() {
  println("Kotlin".lastChar()) // n
}
```

### 3.3.1 Imports and extension functions

It doesn't automatically  become available across your entire project. It needs to be imported

```kotlin
import strings.lastChar
// import strings.*
val c = "Kotlin".lastChar()
```

```kotlin
import strings.lastChar as last
val c = "Kotlin".last()
```



### 3.3.2 Calling extension functions from Java

An extension function is a static method that accepts the receiver object as its first argument. Calling it doesnt involve creating adapter objects or any run-time overhead.

Just as with other top-level functions, **the name of the Java class containing the method is determined from the name of the file where the function is declared**. Let’s say it was declared in a **StringUtil.kt** file:

```java
char c = StringUtilKit.lastChar("Java");
```

### 3.3.3 Utility functions as extensions

```kotlin
fun <T> Collection<T>.joinToString(
        separator: String = ", ",
        prefix: String = "",
        postfix: String = ""
): String {/** 
“for ((index, element) in this.withIndex()) {     ❸
        if (index > 0) result.append(separator)
        result.append(element)
    }”
**/}
// Declares an extension function on Collection<T>
// Assigns default values for parameters
// The keyword this refers to the receiver object: a collection of T.
```

We could be more specific with the type as a receiver type, not only a class. 

```kotlin
fun Collection<String>.join()
```

### 3.3.4 No overriding for extension functions

“Method overriding in Kotlin works as usual for member functions, but **you can’t override an extension function**”

```kotlin
/* Button is the subclass of View */
fun View.showOff() = println("I'm a view!")
fun Button.showOff() = println("I'm a button!")

fun main() {
    val view: View = Button()
    view.showOff()
}
// I'm a view
```

“the function that’s called depends on the declared static type of the variable, determined at compile time, not the run-time type of the value stored in that variable.”

### 3.3.5 Extension Properties

These allow you to **extend classes with API**s that can be accessed **using the property syntax**, rather than the function syntax”

```kotlin
val String.lastChar: Char
	get() = this.get(length - 1)

var StringBuilder.lastChar: Char 
	get() = this.get(length - 1)
	set(value) {
    this.setCharAt(length - 1, value)
  }
```

Note that if you need to access extension property from Java, you have to invoke its getter and setter explicitly.

## 3.4 Working with collections: varags, infix calls, and library support

| Features                           | Descriptions                                               |
| ---------------------------------- | ---------------------------------------------------------- |
| **vararg** keyword                 | declare a function taking an arbitary numbers of arguments |
| **infix** notation                 | lets you call some one-argument function without ceremony  |
| **destructuring** **declarations** | unpack a single composite value into multiple variables    |

### 3.4.1 Extending the Java collections API

```kotlin
fun main() {
    val strings: List<String> = listOf("first", "second", "fourteenth")
    strings.last()
    // fourteenth
 
    val numbers: Collection<Int> = setOf(1, 14, 2)
    numbers.sum()
    // 17
}
```

The reason why it works because  `last` and `sum` are declared as extension functions and are always imported by default in you Kotlin files. 

```kotlin
fun <T> List<T>.last(): T { /* returns the last element */ }
fun Collection<Int>.sum(): Int { /* sum up all elements */ }
```

[kotlin-stdlib - Kotlin Programming Language (kotlinlang.org)](https://kotlinlang.org/api/latest/jvm/stdlib/)  lists all the methods available for each library class - member as well as extensions.

### 3.4.2 Varargs: Functions that accept an arbitrary  number of arguments

```kotlin
val list = listOf(2, 3, 5, 7, 11)
fun listOf<T>(vararg values: T): List<T> { /* implementation */ }
```

In Java, it use three dots after the type. In Kotlin, it uses vararg modifier on the parameter.

The syntax of calling the function. In Java, you pass the array as is, whereas Kotlin requires you to explicitily unpacked the array so that every array element becomes a separate argument to the function being called. **spread operator**

```kotlin
fun main(args: Array<String>) {
    val list = listOf("args: ", *args)  // spread operator
    println(list)
}
```

### 3.4.3 Working with pairs: Infix calls and destructuring declarations

```kotlin
val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V>
```

The word `to` in this line of code isn’t a built-in construct but, rather, a method invocation of a special kind, `an infix call`.

The simpified version of the declaration of the `to` function

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)
```

```kotlin
val (number, name) = 1 to "one // destructuring declaration
```

## 3.5 Working with strings and regular expressions

Kotin strings are exactly the same as Java strings but providing more enjoyable extensions.

### 3.5.1 Splitting strings

```kotlin
fun main() {
    println("12.345-6.A".split("\\.|-".toRegex()))    ❶
    // [12, 345, 6, A]
}
```

```kotlin
fun main() {
    println("12.345-6.A".split(".", "-"))    ❶
    // [12, 345, 6, A]
}
```

### 3.5.2 Regular expression and triple-quote-strings

```kotlin
fun parsePath(path: String) {
    val directory = path.substringBeforeLast("/")
    val fullName = path.substringAfterLast("/")
 
    val fileName = fullName.substringBeforeLast(".")
    val extension = fullName.substringAfterLast(".")
 
    println("Dir: $directory, name: $fileName, ext: $extension")
}
 
fun main() {
    parsePath("/Users/yole/kotlin-book/chapter.adoc")
    // Dir: /Users/yole/kotlin-book, name: chapter, ext: adoc
}
```

```kotlin
fun parsePathRegex(path: String) {
    val regex = """(.+)/(.+)\.(.+)""".toRegex()
    val matchResult = regex.matchEntire(path)
    if (matchResult != null) {
        val (directory, filename, extension) = matchResult.destructured
        println("Dir: $directory, name: $filename, ext: $extension")
    }
}
 
fun main() {
    parsePathRegex("/Users/yole/kotlin-book/chapter.adoc")
    // Dir: /Users/yole/kotlin-book, name: chapter, ext: adoc
}
```

In this example, the regular expression is written in a triple-quoted string. In such a string, you don’t need to escape any characters, including the backslash, so you can encode a regular expression matching a literal dot with \., rather than \\., as you’d write in an ordinary string literal.

![image-20240722024444105](/Users/chiyuchan/Library/Application Support/typora-user-images/image-20240722024444105.png)

### 3.5.3 Multiline triple-quoted strings

```kotlin
val kotlinLogo =
    """
    | //
    |//
    |/ \
    """.trimIndent()
 
fun main() {
    println(kotlinLogo)
    // | //
    // |//
    // |/ \
}
```

## 3.6 Making your code tidy: Local functions and extensions

Kotlin gives you a cleaner solution: you can nest the functions you’ve extracted in the containing function. This way, you have the structure you need without any extra syntactic overhead.

```kotlin
// Code with Duplication
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User) {
    if (user.name.isEmpty()) {
        throw IllegalArgumentException(
            "Can't save user ${user.id}: empty Name")
    }

    if (user.address.isEmpty()) {
        throw IllegalArgumentException(
            "Can't save user ${user.id}: empty Address")
    }

    // Save user to the database
}

fun main() {
    saveUser(User(1, "", ""))
}

/**
code smells, duplicated validation logic
**/

```

```kotlin
// Fixed it , with extension and local validate function
class User(val id: Int, val name: String, val address: String)

fun User.validateBeforeSave() {
    fun validate(value: String, fieldName: String) {
        if (value.isEmpty()) {
            throw IllegalArgumentException(
               "Can't save user $id: empty $fieldName")
        }
    }

    validate(name, "Name")
    validate(address, "Address")
}

fun saveUser(user: User) {
    user.validateBeforeSave()

    // Save user to the database
}

fun main() {
    saveUser(User(1, "", ""))
}

```

